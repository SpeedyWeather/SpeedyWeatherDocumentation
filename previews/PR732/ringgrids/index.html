<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>RingGrids · SpeedyWeather.jl</title><meta name="title" content="RingGrids · SpeedyWeather.jl"/><meta property="og:title" content="RingGrids · SpeedyWeather.jl"/><meta property="twitter:title" content="RingGrids · SpeedyWeather.jl"/><meta name="description" content="Documentation for SpeedyWeather.jl."/><meta property="og:description" content="Documentation for SpeedyWeather.jl."/><meta property="twitter:description" content="Documentation for SpeedyWeather.jl."/><meta property="og:url" content="https://speedyweather.github.io/SpeedyWeatherDocumentation/stable/ringgrids/"/><meta property="twitter:url" content="https://speedyweather.github.io/SpeedyWeatherDocumentation/stable/ringgrids/"/><link rel="canonical" href="https://speedyweather.github.io/SpeedyWeatherDocumentation/stable/ringgrids/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpeedyWeather.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Running SpeedyWeather</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../how_to_run_speedy/">How to run SpeedyWeather</a></li><li><a class="tocitem" href="../examples_2D/">Examples 2D</a></li><li><a class="tocitem" href="../examples_3D/">Examples 3D</a></li><li><a class="tocitem" href="../initial_conditions/">Initial conditions</a></li><li><a class="tocitem" href="../tracers/">Tracer advection</a></li><li><a class="tocitem" href="../particles/">Particle advection</a></li><li><a class="tocitem" href="../stochastic_physics/">Stochastic physics</a></li><li><a class="tocitem" href="../land/">Land surface model</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../structure/">Tree structure</a></li><li><a class="tocitem" href="../differentiability/">Differentiability and Adjoint Model</a></li><li><a class="tocitem" href="../output/">NetCDF output</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Extending SpeedyWeather</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../extensions/">Extensions</a></li><li><a class="tocitem" href="../forcing_drag/">Forcing and drag</a></li><li><a class="tocitem" href="../parameterizations/">Parameterizations</a></li><li><a class="tocitem" href="../orography/">Orography</a></li><li><a class="tocitem" href="../land_sea_mask/">Land-Sea Mask</a></li><li><a class="tocitem" href="../ocean/">Ocean</a></li><li><a class="tocitem" href="../custom_netcdf_output/">NetCDF output variables</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Dynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../barotropic/">Barotropic model</a></li><li><a class="tocitem" href="../shallowwater/">Shallow water model</a></li><li><a class="tocitem" href="../primitiveequation/">Primitive equation model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../large_scale_condensation/">Large-scale condensation</a></li><li><a class="tocitem" href="../convection/">Convection</a></li><li><a class="tocitem" href="../radiation/">Radiation</a></li><li><a class="tocitem" href="../vertical_diffusion/">Vertical diffusion</a></li><li><a class="tocitem" href="../surface_fluxes/">Surface fluxes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Discretization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../spectral_transform/">Spherical Harmonic Transform</a></li><li><a class="tocitem" href="../grids/">Grids</a></li></ul></li><li class="is-active"><a class="tocitem" href>RingGrids</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Defined-grids"><span>Defined grids</span></a></li><li><a class="tocitem" href="#Grid-versus-Field"><span>Grid versus Field</span></a></li><li><a class="tocitem" href="#Creating-a-grid"><span>Creating a grid</span></a></li><li><a class="tocitem" href="#Accessing-coordinates"><span>Accessing coordinates</span></a></li><li><a class="tocitem" href="#Creating-a-Field"><span>Creating a Field</span></a></li><li><a class="tocitem" href="#Creating-a-Field-from-data"><span>Creating a Field from data</span></a></li><li><a class="tocitem" href="#Visualising-Fields"><span>Visualising Fields</span></a></li><li><a class="tocitem" href="#Indexing-Fields"><span>Indexing Fields</span></a></li><li><a class="tocitem" href="#Interpolation-between-grids"><span>Interpolation between grids</span></a></li><li><a class="tocitem" href="#Interpolation-on-coordinates"><span>Interpolation on coordinates</span></a></li><li><a class="tocitem" href="#Performance-for-RingGrid-interpolation"><span>Performance for RingGrid interpolation</span></a></li><li><a class="tocitem" href="#Anvil-interpolator"><span>Anvil interpolator</span></a></li><li><a class="tocitem" href="#Function-index"><span>Function index</span></a></li></ul></li><li><a class="tocitem" href="../lowertriangularmatrices/">LowerTriangularArrays</a></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">SpeedyTransforms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../speedytransforms/">Spectral transforms</a></li><li><a class="tocitem" href="../gradients/">Gradient operators</a></li></ul></li><li><a class="tocitem" href="../functions/">Function and type index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>RingGrids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>RingGrids</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SpeedyWeather/SpeedyWeather.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/main/docs/src/ringgrids.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="RingGrids"><a class="docs-heading-anchor" href="#RingGrids">RingGrids</a><a id="RingGrids-1"></a><a class="docs-heading-anchor-permalink" href="#RingGrids" title="Permalink"></a></h1><p>RingGrids is a submodule that has been developed for SpeedyWeather.jl which is technically independent (SpeedyWeather.jl however imports it and so does SpeedyTransforms) and can also be used without running simulations. It is just not put into its own respective repository.</p><p>RingGrids defines several iso-latitude grids, which are mathematically described in the section on <a href="../grids/#Grids">Grids</a>. In brief, they include the regular latitude-longitude grids (here called <code>FullClenshawGrid</code>) as well as grids which latitudes are shifted to the Gaussian latitudes and <em>reduced</em> grids, meaning that they have a decreasing number of longitudinal points towards the poles to be more equal-area than <em>full</em> grids.</p><h1 id="Defined-grids"><a class="docs-heading-anchor" href="#Defined-grids">Defined grids</a><a id="Defined-grids-1"></a><a class="docs-heading-anchor-permalink" href="#Defined-grids" title="Permalink"></a></h1><p>RingGrids defines and exports the following grids.</p><p>Full grids</p><pre><code class="language-julia hljs">using SpeedyWeather.RingGrids
subtypes(RingGrids.AbstractFullGrid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Any}:
 FullClenshawGrid
 FullGaussianGrid
 FullHEALPixGrid
 FullOctaHEALPixGrid</code></pre><p>and reduced grids</p><pre><code class="language-julia hljs">subtypes(RingGrids.AbstractReducedGrid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Any}:
 HEALPixGrid
 OctaHEALPixGrid
 OctahedralClenshawGrid
 OctahedralGaussianGrid
 OctaminimalGaussianGrid</code></pre><p>The following explanation of how to use these can be mostly applied to any of them, however, there are certain functions that are not defined, e.g. the full grids can be trivially converted to a <code>Matrix</code> (i.e. they are <em>rectangular</em> grids) but not the <code>OctahedralGaussianGrid</code>.</p><div class="admonition is-info" id="What-is-a-ring?-4e4ceea22d7df2d8"><header class="admonition-header">What is a ring?<a class="admonition-anchor" href="#What-is-a-ring?-4e4ceea22d7df2d8" title="Permalink"></a></header><div class="admonition-body"><p>We use the term <em>ring</em>, short for <em>iso-latitude ring</em>, to refer to a sequence of grid points that all share the same latitude. A latitude-longitude grid is a ring grid, as it organises its grid-points into rings. However, other grids, like the <a href="https://en.wikipedia.org/wiki/Quadrilateralized_spherical_cube">cubed-sphere</a> are not based on iso-latitude rings. SpeedyWeather.jl only works with ring grids because its a requirement for the <a href="../spectral_transform/#Spherical-Harmonic-Transform">Spherical Harmonic Transform</a> to be efficient. See <a href="../grids/#Grids">Grids</a>.</p></div></div><h2 id="Grid-versus-Field"><a class="docs-heading-anchor" href="#Grid-versus-Field">Grid versus Field</a><a id="Grid-versus-Field-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-versus-Field" title="Permalink"></a></h2><p>With &quot;grid&quot; we mean the discretization of space. Also called tesselation given that we are tiling a space with polygons, we subdivide the sphere into grid cells, with vertices, faces and centres. In that sense, a grid does not contain any data it purely describes the location of grid cells. Grids in RingGrids are identified by their name, e.g. FullGaussianGrid, and a resolution parameter where we use <code>nlat_half</code> (the number of latitudes on one hemisphere, Equator included) for all grids. This is because some grids have an even number some an odd number number of latitudes so not all <code>nlat</code> are valid, but all <code>nlat_half</code> are. While an instance of a grid stores some precomputed arrays to facilitate faster indexing it does not store coordinates and similar grid information, these can be recomputed on the fly whenever needed given a grid. All grids are considered to be two-dimensional, so they do not contain information about the vertical or time, for example. The horizontal grid points are unravelled into a vector, starting at 0˚E at the north pole, going first east, then ring by ring to the south pole.</p><p>Data on a grid is called a <code>Field</code>, many variables, like temperature are a field. Surface temperature would be a 2D field (though represented as a vector), temperature on several vertical layers of the atmosphere would be 3D (data represented as a matrix, horizontal x vertical), including time would make it 4D. Several fields can share the same grid. Given that the grid is always two-dimensional, a 2D and 3D field can also share the same grid, leaving the 3rd dimension not further specified for flexibility. </p><h2 id="Creating-a-grid"><a class="docs-heading-anchor" href="#Creating-a-grid">Creating a grid</a><a id="Creating-a-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-grid" title="Permalink"></a></h2><p>All grids are specified by name and the resolution parameter <code>nlat_half::Integer</code> (number of latitude rings on one hemisphere, Equator included). An instance of a grid is simply created by</p><pre><code class="language-julia hljs">grid = FullGaussianGrid(24)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">48-ring FullGaussianGrid
├ nlat_half=24 (4608 points, ~2.99˚, full)
└ architecture: SpeedyWeather.RingGrids.DummyArchitecture</code></pre><p>As a second argument <code>architecture</code> can be provided which helps to share information on the computing architecture (CPU/GPU) but this will not be further explained here. </p><h2 id="Accessing-coordinates"><a class="docs-heading-anchor" href="#Accessing-coordinates">Accessing coordinates</a><a id="Accessing-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-coordinates" title="Permalink"></a></h2><p>With a <code>grid</code> you can get the coordinates through <code>get_lat</code>, <code>get_latd</code>, <code>get_colat</code>, <code>get_lond</code> but note that the latter is only defined for full grids as the reduced grids do not share the same longitudes across rings. To obtain the longitudes and latitudes for all grid points use <code>get_londlatds</code>, <code>get_lonlats</code>, <code>get_loncolats</code>, e.g.</p><pre><code class="language-julia hljs">grid = OctaminimalGaussianGrid(2)   # a tiny grid with 4 latitudes only
get_latd(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
  59.44440828916677
  19.87571914744092
 -19.875719147440904
 -59.44440828916677</code></pre><h2 id="Creating-a-Field"><a class="docs-heading-anchor" href="#Creating-a-Field">Creating a Field</a><a id="Creating-a-Field-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Field" title="Permalink"></a></h2><p>Creating <code>Field</code>, that means data on a grid can be done in many ways, for example using <code>zeros</code>, <code>ones,</code>rand<code>, or</code>randn`</p><pre><code class="language-julia hljs">grid = HEALPixGrid(2)               # smallest HEALPix
field = zeros(grid)                 # 2D field
field = rand(grid, 10)              # 3D field with 10 vertical layers or time steps
field = randn(Float32, grid, 2, 2)  # 4D using Float32 as element type</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12×2×2, 3-ring HEALPixField{Float32, 3}:
[:, :, 1] =
  0.56375    1.04275
  0.24798    0.205433
  0.367311   1.54549
 -0.277966   0.291509
 -0.077809  -0.275442
  1.1505    -0.103696
  1.708     -0.3625
 -1.44639   -0.432482
  0.802202  -1.40018
  1.38823   -1.00012
 -2.28841   -1.22261
 -0.169604  -0.174813

[:, :, 2] =
 -0.856552    -0.115961
  0.820857    -1.51992
 -0.6256      -0.0162026
  0.00974021   0.881491
 -0.39891      0.31353
  2.075        0.748379
  0.649459     0.881274
 -2.35438     -1.12761
  0.107548     0.748362
  0.419898    -0.383447
 -0.314402     1.40513
 -0.817883    -0.193797</code></pre><p>Note that in this case all fields share the same <code>grid</code>. Or the grid can be created on the fly when the grid type is specified, followed by <code>nlat_half</code>. Every <code>?Grid</code> also has a corresponding <code>?Field</code> type, e.g.</p><pre><code class="language-julia hljs">field = zeros(OctaminimalGaussianGrid, 2)   # nlat_half=2
field = HEALPixField(undef, 2)              # using undef initializor
field = HEALPixField{Float16}(undef, 2, 3)  # using Float16 as eltype</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12×3, 3-ring HEALPixField{Float16, 2}:
 1.0e-7  1.0e-7  1.0e-7
 0.0     0.0     0.0
 0.0     1.0e-7  1.0e-7
 0.0     0.0     0.0
 2.0e-7  1.0e-7  1.0e-7
 0.0     0.0     0.0
 0.0     1.0e-7  1.0e-7
 0.0     0.0     0.0
 2.4e-7  1.0e-7  1.0e-7
 0.0     0.0     0.0
 0.0     1.0e-7  1.0e-7
 0.0     0.0     0.0</code></pre><h2 id="Creating-a-Field-from-data"><a class="docs-heading-anchor" href="#Creating-a-Field-from-data">Creating a Field from data</a><a id="Creating-a-Field-from-data-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Field-from-data" title="Permalink"></a></h2><p>A <code>field</code> has <code>field.data</code> (some <code>AbstractArray{T, N}</code>) and <code>field.grid</code> (some <code>AbstractGrid</code> as described above). The first dimension of <code>data</code> describes the horizontal as the grid points on every grid (full and reduced) are unravelled west to east then north to south, meaning that it starts at 90˚N and 0˚E then walks eastward for 360˚ before jumping on the next latitude ring further south, this way circling around the sphere till reaching the south pole. This may also be called <em>ring order</em>.</p><p>Data in a <code>Matrix</code> which follows this ring order can be put on a <code>FullGaussianGrid</code> like so</p><pre><code class="language-julia hljs">data = randn(Float32, 8, 4)
field = FullGaussianGrid(data, input_as=Matrix)
field = FullGaussianField(data, input_as=Matrix)    # equivalent</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">32-element, 4-ring FullGaussianField{Float32, 1}:
 -2.852835
 -0.6202498
  2.3144612
  0.78139436
  0.7354708
 -0.6882388
  0.3935247
  1.3953409
 -0.771884
 -0.9648962
  ⋮
  0.10450825
 -0.40006062
  0.59731764
 -1.5947759
  0.21457809
 -0.040189262
 -0.2667355
 -1.950322
  0.12122941</code></pre><p>Both return a field (there is no data in the grid itself) and create an instance of <code>FullGaussianGrid</code> on the fly. The <code>input_as=Matrix</code> is required to denote that the horizontal dimension is not unravelled into a vector, triggering a <code>reshape</code> internally, <code>input_as=Vector</code> is the default. A full Gaussian grid has always <span>$2N$</span> x <span>$N$</span> grid points, but a <code>FullClenshawGrid</code> has <span>$2N$</span> x <span>$N-1$</span>, if those dimensions don&#39;t match, the creation will throw an error.</p><p>If you have the data and know which grid it comes one you can also create a <code>Field</code> by providing both</p><pre><code class="language-julia hljs">data = randn(Float32, 8, 4)         # data of some shape
grid = OctaminimalGaussianGrid(1)   # you need to know the nlat_half (here 1) of that grid!
field = Field(data, grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8×4, 2-ring OctaminimalGaussianField{Float32, 2}:
 -0.544872  -1.00373    1.66832   -0.723818
 -0.719442   1.24238   -0.485193   0.724279
 -0.394944   1.08514    0.102127   0.0360136
 -0.850132   0.338575   0.884069  -0.659707
  0.903572   0.715901   0.465761   1.55655
 -1.75085   -2.41422   -0.822543  -1.33041
 -1.59219    0.254568  -1.90568   -0.206979
 -0.76742   -0.022275   1.12088    0.823669</code></pre><p>But you can also automatically let <code>nlat_half</code> be calculated from the shape of the data. Note that you have to provide the name of the field though, <code>FullGaussianField</code> here to create a <code>Field</code> on a <code>FullGaussianGrid</code>.</p><pre><code class="language-julia hljs">field = FullGaussianField(data, input_as=Matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">32-element, 4-ring FullGaussianField{Float32, 1}:
 -0.5448722
 -0.71944165
 -0.3949442
 -0.8501315
  0.9035725
 -1.7508496
 -1.5921855
 -0.76742005
 -1.0037317
  1.2423816
  ⋮
  1.1208777
 -0.72381777
  0.7242793
  0.036013626
 -0.65970683
  1.5565485
 -1.3304058
 -0.2069787
  0.8236686</code></pre><p>To return to the original data array you can reshape the data of a full grid (which is representable as a matrix) as follows</p><pre><code class="language-julia hljs">data == Matrix(FullGaussianField(data, input_as=Matrix))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>which in general is <code>Array(field, as=Vector)</code> for no reshaping (equivalent to <code>field.data</code> including possible conversion to <code>Array</code>) and <code>Array(field, as=Matrix)</code> with reshaping (full grids only).</p><h2 id="Visualising-Fields"><a class="docs-heading-anchor" href="#Visualising-Fields">Visualising Fields</a><a id="Visualising-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Visualising-Fields" title="Permalink"></a></h2><p>As only the full fields can be reshaped into a matrix, the underlying data structure of any <code>AbstractField</code> is a vector for consistency. As shown in the examples above, one can therefore inspect the data as if it was a vector. But a field has through <code>field.grid</code> all the geometric information available to plot it on a map, SpeedyWeather also implements extensions for <a href="https://github.com/MakieOrg/Makie.jl">Makie&#39;s</a> and <a href="https://github.com/JuliaPlots/UnicodePlots.jl">UnicodePlots&#39;s</a>&#39; <code>heatmap</code>, also see <a href="../examples_2D/#Visualisation-via-Makie">Visualisation via Makie</a> and <a href="../examples_2D/#Visualisation-via-UnicodePlots">Visualisation via UnicodePlots</a>.</p><pre><code class="language-julia hljs">using CairoMakie    # triggers loading of Makie extension, or do using UnicodePlots instead!
grid = OctahedralGaussianGrid(24)
field = randn(grid)
heatmap(field)</code></pre><img src="ef98c6e9.png" alt="Example block output"/><p>Reduced fields are automatically interpolated to the corresponding full fields so that they can be visualised as a matrix.</p><h2 id="Indexing-Fields"><a class="docs-heading-anchor" href="#Indexing-Fields">Indexing Fields</a><a id="Indexing-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-Fields" title="Permalink"></a></h2><p>All fields have a single index <code>ij</code> which follows the ring order. While this is obviously not super exciting here are some examples how to make better use of the information that the data sits on a two-dimensional grid covering the sphere. We obtain the latitudes of the rings of a grid by calling <code>get_latd</code> (<code>get_lond</code> is only defined for full grids, or use <code>get_londlatds</code> for latitudes, longitudes per grid point not per ring). Now we could calculate Coriolis and add it on the grid as follows</p><pre><code class="language-julia hljs">grid = OctahedralClenshawGrid(5)    # define a grid
field = randn(grid)                 # random data on that grid
latd = get_latd(grid)               # get a vector of latitudes [˚N] per ring, north to south

rotation = 7.29e-5                  # angular frequency of Earth&#39;s rotation [rad/s]
coriolis = 2rotation*sind.(latd)    # vector of coriolis parameters per latitude ring

for (j, ring) in enumerate(eachring(field))     # loop over every ring j
    f = coriolis[j]
    for ij in ring                              # loop over every longitude point on that ring
        field[ij] += f
    end
end</code></pre><p><code>eachring(field)</code> accesses <code>field.grid.rings</code> a precomputed vector of <code>UnitRange</code> indices, such that we can loop over the ring index <code>j</code> (<code>j=1</code> being closest to the North pole) pull the coriolis parameter at that latitude and then loop over all in-ring indices <code>i</code> (changing longitudes) to do something on the grid. Something similar can be done to scale/unscale with the cosine of latitude for example.</p><p>We can always loop over all horizontal grid points with <code>eachgridpoint</code> and over every other dimensions with <code>eachlayer</code>, e.g. for 2D fields you can do</p><pre><code class="language-julia hljs">for ij in eachgridpoint(grid)
    field[ij]
end</code></pre><p>or use <code>eachindex</code> instead. For 3D fields <code>eachindex</code> loops over all elements, including the 3rd dimension but <code>eachgridpoint</code> would only loop over the horizontal. To loop with an index <code>k</code> over all additional dimensions (vertical, time, ...) do</p><pre><code class="language-julia hljs">field = zeros(grid, 2, 3)           # 4D, 2D defined by grid x 2 x 3
for k in eachlayer(field)           # loop over 2 x 3
    for ij in eachgridpoint(field)  # loop over 2D grid points
        field[ij, k]
    end
end</code></pre><h2 id="Interpolation-between-grids"><a class="docs-heading-anchor" href="#Interpolation-between-grids">Interpolation between grids</a><a id="Interpolation-between-grids-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-between-grids" title="Permalink"></a></h2><p>In most cases we will want to use RingGrids so that our data directly comes with the geometric information of where the grid-point is one the sphere. We have seen how to use <code>get_latd</code>, <code>get_lond</code>, ... for that above. This information generally can also be used to interpolate our data from one grid to another or to request an interpolated value on some coordinates. Using a <code>OctahedralGaussianField</code> (data on an <code>OctahedralGaussianGrid</code>) from above we can use the <code>interpolate</code> function to get it onto a <code>FullGaussianGrid</code> (or any other grid for purpose)</p><pre><code class="language-julia hljs">grid = OctahedralGaussianGrid(4)
field = randn(Float32, grid)
interpolate(FullGaussianGrid, field)</code></pre><p>By default this will linearly interpolate (it&#39;s an <a href="#Anvil-interpolator">Anvil interpolator</a>, see below) onto a grid with the same <code>nlat_half</code>, but we can also coarse-grain or fine-grain by specifying any other <code>grid</code> as an instance not a type (or provide <code>nlat_half</code> as the second argument), e.g.</p><pre><code class="language-julia hljs">output_grid = HEALPixGrid(6)
interpolate(output_grid, field)
interpolate(HEALPixGrid, 6, field)  # equivalent</code></pre><p>To change the number format during interpolation you can preallocate the output field</p><pre><code class="language-julia hljs">output_field = Field(Float16, output_grid)
interpolate!(output_field, field)</code></pre><p>Which will convert from <code>Float64</code> to <code>Float16</code> on the fly too. Note that we use <code>interpolate!</code> here not <code>interpolate</code> without <code>!</code> as the former writes into <code>output_field</code> and therefore changes it in place.</p><h2 id="Interpolation-on-coordinates"><a class="docs-heading-anchor" href="#Interpolation-on-coordinates">Interpolation on coordinates</a><a id="Interpolation-on-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-on-coordinates" title="Permalink"></a></h2><p>One can also interpolate a 2D field onto a given coordinate ˚N, ˚E like so</p><pre><code class="language-julia hljs">interpolate(30.0, 10.0, field)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.21328561f0</code></pre><p>we interpolated the data from <code>field</code> onto 30˚N, 10˚E. To do this simultaneously for many coordinates they can be packed into a vector too</p><pre><code class="language-julia hljs">interpolate([30.0, 40.0, 50.0], [10.0, 10.0, 10.0], field)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float32}:
 -0.21328561
 -0.38506827
  0.16640627</code></pre><p>which returns the data on <code>field</code> at 30˚N, 40˚N, 50˚N, and 10˚E respectively. Note how the interpolation here retains the element type of <code>field</code>.</p><h2 id="Performance-for-RingGrid-interpolation"><a class="docs-heading-anchor" href="#Performance-for-RingGrid-interpolation">Performance for RingGrid interpolation</a><a id="Performance-for-RingGrid-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-for-RingGrid-interpolation" title="Permalink"></a></h2><p>Every time an interpolation like <code>interpolate(30.0, 10.0, field)</code> is called, several things happen, which are important to understand to know how to get the fastest interpolation out of this module in a given situation. Under the hood an interpolation takes three arguments</p><ul><li>output array</li><li>input field</li><li>interpolator</li></ul><p>The output array is just an array into which the interpolated data is written, providing this prevents unnecessary allocation of memory in case the destination array of the interpolation already exists. Such a destination can be a field but it does not have to be (see <a href="#Interpolation-on-coordinates">Interpolation on coordinates</a>). The input field contains the data which is subject to interpolation, it must come on a ring grid, however, its coordinate information is actually already in the interpolator. The interpolator knows about the geometry of the grid of the field and the coordinates it is supposed to interpolate onto. It has therefore precalculated the indices that are needed to access the right data on the input field and the weights it needs to apply in the actual interpolation operation. The only thing it does not know is the actual data values of that field. So in the case you want to interpolate from field A to field B many times, you can just reuse the same interpolator. If you want to change the coordinates of the output but its total number of points remain constant then you can update the locator inside the interpolator and only else you will need to create a new interpolator. Let&#39;s look at this in practice. Say we have two grids and want to interpolate between them</p><pre><code class="language-julia hljs">grid_in = HEALPixGrid(4)
grid_out = FullClenshawGrid(6)
interp = RingGrids.interpolator(grid_out, grid_in)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnvilInterpolator{Float64} for 7-ring HEALPixGrid
├ nlat_half=4 (48 points, ~29.3˚, reduced)
└ architecture: SpeedyWeather.RingGrids.DummyArchitecture
└ onto: 264 points</code></pre><p>Now we have created an interpolator <code>interp</code> which knows about the geometry where to interpolate <em>from</em> and the coordinates there to interpolate <em>to</em>. It is also initialized, meaning it has precomputed the indices to of <code>grid_in</code> that are supposed to be used. It just does not know about the data (it has only seen grids, no fields). We can now do</p><pre><code class="language-julia hljs">field_in = rand(grid_in)
field_out = zeros(grid_out)
interpolate!(field_out, field_in, interp)</code></pre><p>which is identical to <code>interpolate(field_out, field_in)</code> but you can reuse <code>interp</code> for other data. The interpolation can also handle various element types (the interpolator <code>interp</code> does not have to be updated for this either)</p><pre><code class="language-julia hljs">field_out = zeros(Float16, grid_out)
interpolate!(field_out, field_in, interp)</code></pre><p>and we have converted data from a <code>HEALPixField{Float64}</code> (<code>Float64</code> is always default if not specified) to a <code>FullClenshawField{Float16}</code> including the type conversion Float64-Float16 on the fly. Technically there are three data types and their combinations possible: The input data will come with a type, the output array has an element type and the interpolator has precomputed weights with a given type. Say we want to go from Float16 data on an <code>OctahedralGaussianGrid</code> to Float16 on a <code>FullClenshawGrid</code> but using Float32 precision for the interpolation itself, we would do this by</p><pre><code class="language-julia hljs">field_in = randn(OctahedralGaussianField{Float16}, 24)
field_out = zeros(FullClenshawField{Float16}, 24)
interp = RingGrids.interpolator(field_out, field_in, NF=Float32)
interpolate!(field_out, field_in, interp)</code></pre><p>As a last example we want to illustrate a situation where we would always want to interpolate onto 10 coordinates, but their locations may change. In order to avoid recreating an interpolator object we would do (<code>AnvilInterpolator</code> is described in <a href="#Anvil-interpolator">Anvil interpolator</a>)</p><pre><code class="language-julia hljs">npoints = 10    # number of coordinates to interpolate onto
grid = HEALPixGrid(24)
interp = AnvilInterpolator(grid, npoints, NF=Float32)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AnvilInterpolator{Float32} for 47-ring HEALPixGrid
├ nlat_half=24 (1728 points, ~4.9˚, reduced)
└ architecture: SpeedyWeather.RingGrids.DummyArchitecture
└ onto: 10 points</code></pre><p>with the first argument being the input grid and then the number of points to interpolate onto. The number format used for the interpolator is provided as <code>NF</code>. However, <code>interp</code> is not yet initialized as it does not know about the destination coordinates yet. Let&#39;s define them, but note that we already decided there&#39;s only 10 of them above.</p><pre><code class="language-julia hljs">londs = collect(-10.0:2.0:8.0)
latds = collect(0.0:5.0:45.0)</code></pre><p>now we can update the locator inside our interpolator as follows</p><pre><code class="language-julia hljs">RingGrids.update_locator!(interp, londs, latds)</code></pre><p>With data matching the input from above, a <code>nlat_half=24</code> HEALPixGrid, and allocate 10-element output vector</p><pre><code class="language-julia hljs">output_vec = zeros(10)
field_in = rand(grid)</code></pre><p>we can use the interpolator as follows</p><pre><code class="language-julia hljs">interpolate!(output_vec, field_in, interp)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Float64}:
 0.5998197294009996
 0.390472237400894
 0.37373929092389563
 0.6060585466241023
 0.6703593665845955
 0.5037196996195836
 0.20014481658838146
 0.1632459205407312
 0.48981184982361037
 0.6072587010934131</code></pre><p>which is the approximately the same as doing it directly without creating an interpolator first and updating its locator</p><pre><code class="language-julia hljs">interpolate(londs, latds, field_in)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Float64}:
 0.5998197293668248
 0.3904722358752377
 0.37373928426087816
 0.6060585512244133
 0.6703593620552539
 0.5037196967573765
 0.20014480761382947
 0.16324592665808124
 0.48981185632719937
 0.6072587014796743</code></pre><p>but allows for a reuse of the interpolator. Note that the two output arrays are not exactly identical because we manually set our interpolator <code>interp</code> to use <code>Float32</code> for the interpolation whereas the default is <code>Float64</code>.</p><h2 id="Anvil-interpolator"><a class="docs-heading-anchor" href="#Anvil-interpolator">Anvil interpolator</a><a id="Anvil-interpolator-1"></a><a class="docs-heading-anchor-permalink" href="#Anvil-interpolator" title="Permalink"></a></h2><p>Currently the only interpolator implemented is a 4-point bilinear interpolator, which schematically works as follows. Anvil interpolation is the bilinear average of a, b, c, d which are values at grid points in an anvil-shaped configuration at location x, which is denoted by Δab, Δcd, Δy, the fraction of distances between a-b, c-d, and ab-cd, respectively. Note that a, c and b, d do not necessarily share the same longitude/x-coordinate.</p><pre><code class="nohighlight hljs">        0..............1    # fraction of distance Δab between a, b
        |&lt;  Δab   &gt;|

0^      a -------- o - b    # anvil-shaped average of a, b, c, d at location x
.Δy                |
.                  |
.v                 x 
.                  |
1         c ------ o ---- d

          |&lt;  Δcd &gt;|
          0...............1 # fraction of distance Δcd between c, d

^ fraction of distance Δy between a-b and c-d.</code></pre><p>This interpolation is chosen as by definition of the ring grids, a and b share the same latitude, so do c and d, but the longitudes can be different for all four, a, b, c, d.</p><h2 id="Function-index"><a class="docs-heading-anchor" href="#Function-index">Function index</a><a id="Function-index-1"></a><a class="docs-heading-anchor-permalink" href="#Function-index" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Type-Union{Tuple{Integer}, Tuple{Grid}, Tuple{Integer, Any}} where Grid&lt;:AbstractGrid" href="#Core.Type-Union{Tuple{Integer}, Tuple{Grid}, Tuple{Integer, Any}} where Grid&lt;:AbstractGrid"><code>Core.Type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create a new <code>grid</code> of type <code>Grid</code> with resolution parameter <code>nlat_half</code>. <code>architecture</code> is the device type (CPU/GPU). Precomputes the ring indices <code>rings</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Type-Union{Tuple{L}, Tuple{Type{&lt;:AbstractFloat}, Integer}} where L&lt;:SpeedyWeather.RingGrids.AbstractLocator" href="#Core.Type-Union{Tuple{L}, Tuple{Type{&lt;:AbstractFloat}, Integer}} where L&lt;:SpeedyWeather.RingGrids.AbstractLocator"><code>Core.Type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Zero generator function for the 4-point average AnvilLocator. Use update_locator! to update the grid indices used for interpolation and their weights. The number format NF is the format used for the calculations within the interpolation, the input data and/or output data formats may differ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/interpolation.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractField" href="#SpeedyWeather.RingGrids.AbstractField"><code>SpeedyWeather.RingGrids.AbstractField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for all fields, i.e. data on a grid. A field is an <code>AbstractArray</code> with a number format <code>T</code>, a number of dimensions <code>N</code>, an <code>ArrayType</code> (e.g. <code>Vector</code>, <code>Matrix</code>, <code>Tensor</code>) and a grid type <code>Grid</code>. Fields can be full or reduced, 2D, 3D, or 4D, depending on the grid and the number of dimensions. Fields are used to store data on the grid, e.g. temperature, pressure, or any other variable. Every <code>Field</code> has <code>data</code> the grid-free array of the data and <code>grid</code> which contains information about the grid the field is defined on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/abstract_types.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractField2D" href="#SpeedyWeather.RingGrids.AbstractField2D"><code>SpeedyWeather.RingGrids.AbstractField2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for all 2D fields, i.e. fields with the horizontal dimensions only. Note that this is a <code>&lt;:AbstractVector</code> as the horizontal dimensions are unravelled into a vector for all grids to be conistent with the reduced grids that cannot be represented as a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/abstract_types.jl#L44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractField3D" href="#SpeedyWeather.RingGrids.AbstractField3D"><code>SpeedyWeather.RingGrids.AbstractField3D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for all 3D fields, i.e. fields with horizontal and one vertical (or time etc) dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/abstract_types.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractField4D" href="#SpeedyWeather.RingGrids.AbstractField4D"><code>SpeedyWeather.RingGrids.AbstractField4D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for all 4D fields, i.e. fields with horizontal and (in most cases) a vertical and a time dimensions, though these additional dimensions are arbitrary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/abstract_types.jl#L52-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractFullField" href="#SpeedyWeather.RingGrids.AbstractFullField"><code>SpeedyWeather.RingGrids.AbstractFullField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for all fields on full grids, i.e. grids with a constant number of longitude points across latitude rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/abstract_types.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractFullGrid" href="#SpeedyWeather.RingGrids.AbstractFullGrid"><code>SpeedyWeather.RingGrids.AbstractFullGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for all full grids, representing a horizontal grid with a constant number of longitude points across latitude rings. Different latitudes can be used, Gaussian latitudes, equi-angle latitudes (also called Clenshaw from Clenshaw-Curtis quadrature), or others.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/abstract_types.jl#L18-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractGrid" href="#SpeedyWeather.RingGrids.AbstractGrid"><code>SpeedyWeather.RingGrids.AbstractGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for all grids in RingGrids.jl, representing a discretization (particularly a tessellation or tiling) of the sphere. A &quot;grid&quot; does not contain any data only its resolution is defined by <code>nlat_half</code> (number of latitude rings on one hemisphere including the equator). A grid does not contain the coordinates of the grid points, vertices, latitudes, longtiudes etc but they can be recomputed from the grid object (or its type and resolution) at any time.</p><p>A grid is regarded as 2D but a field (data on a grid) can have N additional dimensions, e.g. for vertical levels or time. In that sense, a grid does not have a number format / eltype. This is a property of a <code>Field</code> which can be different for every field even when using the same grid. Points on the grid (cell centres) are unravalled into a vector ordered 0 to 360˚E, starting at the north pole, then going ring by ring to the south pole. This way both full (those representable as a matrix) and reduced grids (not representable as a matrix, with fewer longitude points towards the poles) can be represented.</p><p>A grid has a parameter <code>Architecture</code> (the type of the field <code>architecture</code>) that can be used to store information about the architecture the grid is on, e.g. CPU or GPU.</p><p>Furthermore all grids have a <code>rings</code> to allow ring-by-ring indexing. Other precomputed indices can be added for specific grids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/abstract_types.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractInterpolator" href="#SpeedyWeather.RingGrids.AbstractInterpolator"><code>SpeedyWeather.RingGrids.AbstractInterpolator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractInterpolator end</code></pre><p>Supertype for Interpolators. Every Interpolator &lt;: AbstractInterpolator is expected to have two fields,</p><ul><li>geometry, which describes the grid G to interpolate from</li><li>locator, which locates the indices on G and their weights to interpolate  onto a new grid.</li></ul><p>NF is the number format used to calculate the interpolation, which can be different from the input data and/or the interpolated data on the new grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/interpolation.jl#L123-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractLocator" href="#SpeedyWeather.RingGrids.AbstractLocator"><code>SpeedyWeather.RingGrids.AbstractLocator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Supertype of every Locator, which locates the indices on a grid to be used to perform an interpolation. E.g. AnvilLocator uses a 4-point stencil for every new coordinate to interpolate onto. Higher order stencils can be implemented by defining OtherLocator &lt;: AbstractLocactor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/interpolation.jl#L66-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractReducedField" href="#SpeedyWeather.RingGrids.AbstractReducedField"><code>SpeedyWeather.RingGrids.AbstractReducedField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for all fields on reduced grids, i.e. grids with a reduced number of longitude points towards the poles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/abstract_types.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractReducedGrid" href="#SpeedyWeather.RingGrids.AbstractReducedGrid"><code>SpeedyWeather.RingGrids.AbstractReducedGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for all reduced grids, representing arrays of ring grids that have a reduced number of longitude points towards the poles, i.e. they are not &quot;full&quot;, see <code>AbstractFullGrid</code>. Data on these grids (a <code>Field</code>) cannot be represented as matrix and has to be unravelled into a vector, ordered 0 to 360˚E then north to south, ring by ring. Examples for reduced grids are the octahedral Gaussian or Clenshaw grids, or the HEALPix grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/abstract_types.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AbstractSphericalDistance" href="#SpeedyWeather.RingGrids.AbstractSphericalDistance"><code>SpeedyWeather.RingGrids.AbstractSphericalDistance</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSphericalDistance end</code></pre><p>Super type of formulas to calculate the spherical distance or great-circle distance. To define a <code>NewFormula</code>, define <code>struct NewFormula &lt;: AbstractSphericalDistance end</code> and the actual calculation as a functor</p><pre><code class="nohighlight hljs">function NewFormula(lonlat1::Tuple, lonlat2::Tuple; radius=DEFAULT_RADIUS, kwargs...)</code></pre><p>assuming inputs in degrees and returning the distance in meters (or radians for radius=1). Then use the general interface <code>spherical_distance(NewFormula, args...; kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/geodesics.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.AnvilLocator" href="#SpeedyWeather.RingGrids.AnvilLocator"><code>SpeedyWeather.RingGrids.AnvilLocator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Contains arrays that locates grid points of a given field to be uses in an interpolation and their weights. This Locator is a 4-point average in an anvil-shaped grid-point arrangement between two latitude rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/interpolation.jl#L71-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.Field" href="#SpeedyWeather.RingGrids.Field"><code>SpeedyWeather.RingGrids.Field</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Field contains data on a grid. There is only one <code>Field</code> type which can be used for all grids. <code>data</code> is the data array, the first dimension is always the horizontal dimension (unravelled into a vector for compatibility across full and reduced grids), the other dimensions can be used for the vertical and/or time or other dimensions. The <code>grid</code> can be shared across multiple fields, e.g. a 2D and a 3D field can share the same grid which just defines the discretization and the architecture (CPU/GPU) the grid is on.</p><ul><li><p><code>data::AbstractArray</code></p></li><li><p><code>grid::AbstractGrid</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/field.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.FullClenshawGrid" href="#SpeedyWeather.RingGrids.FullClenshawGrid"><code>SpeedyWeather.RingGrids.FullClenshawGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>FullClenshawGrid</code> is a discretization of the sphere, a full grid, subtyping <code>AbstractFullGrid</code>, using equidistant latitudes for each ring (a regular lon-lat grid). These require the Clenshaw-Curtis quadrature in the spectral transform, hence the name. One ring is on the equator, total number of rings is odd, no rings on the north or south pole.</p><p>The first dimension of data on this grid (a <code>Field</code>) represents the horizontal dimension, in ring order (0 to 360˚E, then north to south), other dimensions can be used for the vertical and/or time or other dimensions.  Note that a <code>Grid</code> does not contain any data, it only describes the discretization of the space, see <code>Field</code> for a data on a <code>Grid</code>.  But a &quot;grid&quot; only defines the two horizontal dimensions, two fields, one 2D and one 3D, possibly different ArrayTypes or element types, can share the same grid which just defines the discretization and the architecture (CPU/GPU) the grid is on.</p><p>The resolution parameter of the horizontal grid is <code>nlat_half</code> (number of latitude rings on one hemisphere, Equator included) and the ring indices are precomputed in <code>rings</code>.</p><ul><li><p><code>nlat_half::Int64</code></p></li><li><p><code>architecture::Any</code></p></li><li><p><code>rings::Any</code></p></li><li><p><code>whichring::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/full_clenshaw.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.FullGaussianGrid" href="#SpeedyWeather.RingGrids.FullGaussianGrid"><code>SpeedyWeather.RingGrids.FullGaussianGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>FullGaussianGrid</code> is a discretization of the sphere that uses Gaussian latitudes for each latitude ring. As a &quot;full&quot; grid it has the same number of longitude points on every latitude ring, i.e. it is  representable as a matrix, with denser grid points towards the poles. The Gaussian latitudes enable to use the Gaussian quadrature for the spectral transform, hence the name. No ring is on the equator, total number of rings is even and symmetric around the Equator, no rings on the north or south pole.</p><p>The first dimension of data on this grid (a <code>Field</code>) represents the horizontal dimension, in ring order (0 to 360˚E, then north to south), other dimensions can be used for the vertical and/or time or other dimensions.  Note that a <code>Grid</code> does not contain any data, it only describes the discretization of the space, see <code>Field</code> for a data on a <code>Grid</code>.  But a &quot;grid&quot; only defines the two horizontal dimensions, two fields, one 2D and one 3D, possibly different ArrayTypes or element types, can share the same grid which just defines the discretization and the architecture (CPU/GPU) the grid is on.</p><p>The resolution parameter of the horizontal grid is <code>nlat_half</code> (number of latitude rings on one hemisphere, Equator included) and the ring indices are precomputed in <code>rings</code>.</p><ul><li><p><code>nlat_half::Int64</code></p></li><li><p><code>architecture::Any</code></p></li><li><p><code>rings::Any</code></p></li><li><p><code>whichring::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/full_gaussian.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.FullHEALPixGrid" href="#SpeedyWeather.RingGrids.FullHEALPixGrid"><code>SpeedyWeather.RingGrids.FullHEALPixGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>FullHEALPixGrid</code> is like a <code>HEALPixGrid</code> but with every latitude ring having the same number of longitude points (a full grid). This grid is mostly defined for output to minimize the interpolation needed from a HEALPixGrid to a full grid. A <code>FullHEALPixGrid</code> has none of the equal-area properties of the <code>HEALPixGrid</code>. It only shares the latitudes with the <code>HEALPixGrid</code> but uses the longitudes from the <code>FullGaussianGrid</code> without offset, i.e. the first longitude point on every ring is at 0˚E.</p><ul><li><p><code>nlat_half::Int64</code></p></li><li><p><code>architecture::Any</code></p></li><li><p><code>rings::Any</code></p></li><li><p><code>whichring::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/full_healpix.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.FullOctaHEALPixGrid" href="#SpeedyWeather.RingGrids.FullOctaHEALPixGrid"><code>SpeedyWeather.RingGrids.FullOctaHEALPixGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>FullOctaHEALPixGrid</code> is like a <code>OctaHEALPixGrid</code> but with every latitude ring having the same number of longitude points (a full grid). This grid is mostly defined for output to minimize the interpolation needed from an <code>OctaHEALPixGrid</code> to a full grid required for output. A <code>FullOctaHEALPixGrid</code> has none of the equal-area properties of the <code>OctaHEALPixGrid</code>. It only shares the latitudes with the <code>OctaHEALPixGrid</code> but uses the longitudes from the <code>FullGaussianGrid</code> without offset, i.e. the first longitude point on every ring is at 0˚E.</p><ul><li><p><code>nlat_half::Int64</code></p></li><li><p><code>architecture::Any</code></p></li><li><p><code>rings::Any</code></p></li><li><p><code>whichring::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/full_octahealpix.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.GridGeometry" href="#SpeedyWeather.RingGrids.GridGeometry"><code>SpeedyWeather.RingGrids.GridGeometry</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Contains general precomputed arrays describing the grid.</p><ul><li><p><code>grid::Any</code></p></li><li><p><code>nlat_half::Int64</code></p></li><li><p><code>nlat::Int64</code></p></li><li><p><code>npoints::Int64</code></p></li><li><p><code>londs::Any</code></p></li><li><p><code>latd::Any</code></p></li><li><p><code>nlons::Any</code></p></li><li><p><code>lon_offsets::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/interpolation.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.GridGeometry-Tuple{AbstractGrid}" href="#SpeedyWeather.RingGrids.GridGeometry-Tuple{AbstractGrid}"><code>SpeedyWeather.RingGrids.GridGeometry</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GridGeometry(
    grid::AbstractGrid;
    NF,
    ArrayType
) -&gt; SpeedyWeather.RingGrids.GridGeometry{&lt;:AbstractGrid{Architecture}, Vector{Float64}, Vector{Int64}} where Architecture
</code></pre><p>Precomputed arrays describing the geometry of the Grid with resolution nlat_half. Contains longitudes, latitudes of grid points, their ring index j and their unravelled indices ij.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/interpolation.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.HEALPixGrid" href="#SpeedyWeather.RingGrids.HEALPixGrid"><code>SpeedyWeather.RingGrids.HEALPixGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>HEALPixGrid</code> is a equal-area discretization of the sphere. A HEALPix grid has 12 faces, each <code>nside</code>x<code>nside</code> grid points, each covering the same area of the sphere. They start with 4 longitude points on the northern-most ring, increase by 4 points per ring in the &quot;polar cap&quot; (the top half of the 4 northern-most faces) but have a constant number of longitude points in the equatorial belt. The southern hemisphere is symmetric to the northern, mirrored around the Equator. HEALPix grids have a ring on the Equator. For more details see Górski et al. 2005, DOI:10.1086/427976. </p><p><code>rings</code> are the precomputed ring indices, for nlat_half = 4 it is <code>rings = [1:4, 5:12, 13:20, 21:28, 29:36, 37:44, 45:48]</code>. So the first ring has indices 1:4 in the unravelled first dimension, etc. For efficient looping see <code>eachring</code> and <code>eachgrid</code>. <code>whichring</code> is a precomputed vector of ring indices for each grid point ij, i.e. <code>whichring[ij]</code> gives the ring index j of grid point ij. Fields are</p><ul><li><p><code>nlat_half::Int64</code></p></li><li><p><code>architecture::Any</code></p></li><li><p><code>rings::Any</code></p></li><li><p><code>whichring::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/healpix.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.Haversine-Tuple{Tuple, Tuple}" href="#SpeedyWeather.RingGrids.Haversine-Tuple{Tuple, Tuple}"><code>SpeedyWeather.RingGrids.Haversine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Haversine(lonlat1::Tuple, lonlat2::Tuple; radius) -&gt; Any
</code></pre><p>Haversine formula calculating the great-circle or spherical distance (in meters) on the sphere between two tuples of  longitude-latitude points in degrees ˚E, ˚N. Use keyword argument <code>radius</code> to change the radius of the sphere (default 6371e3 meters, Earth&#39;s radius), use <code>radius=1</code> to return the central angle in radians or <code>radius=360/2π</code> to return degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/geodesics.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.OctaHEALPixGrid" href="#SpeedyWeather.RingGrids.OctaHEALPixGrid"><code>SpeedyWeather.RingGrids.OctaHEALPixGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An <code>OctaHEALPixGrid</code> is an equal-area discretization of the sphere. It has 4 faces, each <code>nlat_half x nlat_half</code> in size, covering 90˚ in longitude, pole to pole. As part of the HEALPix family of grids, the grid points are equal area. They start with 4 longitude points on the northern-most ring, increase by 4 points per ring  towards the Equator with one ring on the Equator before reducing the number of points again towards the south pole by 4 per ring. There is no equatorial belt for OctaHEALPix grids. The southern hemisphere is symmetric to the northern, mirrored around the Equator. OctaHEALPix grids have a ring on the Equator. For more details see Górski et al. 2005, DOI:10.1086/427976, the OctaHEALPix grid belongs to the family of HEALPix grids with Nθ = 1, Nφ = 4 but is not explicitly mentioned therein.</p><p><code>rings</code> are the precomputed ring indices, for nlat_half = 3 (in contrast to HEALPix this can be odd) it is <code>rings = [1:4, 5:12, 13:24, 25:32, 33:36]</code>. For efficient looping see <code>eachring</code> and <code>eachgrid</code>. <code>whichring</code> is a precomputed vector of ring indices for each grid point ij, i.e. <code>whichring[ij]</code> gives the ring index j of grid point ij. Fields are</p><ul><li><p><code>nlat_half::Int64</code></p></li><li><p><code>architecture::Any</code></p></li><li><p><code>rings::Any</code></p></li><li><p><code>whichring::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/octahealpix.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.OctahedralClenshawGrid" href="#SpeedyWeather.RingGrids.OctahedralClenshawGrid"><code>SpeedyWeather.RingGrids.OctahedralClenshawGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An <code>OctahedralClenshawGrid</code> is a discretization of the sphere that uses equidistant latitudes for each latitude ring. The spherical harmonic transform on this grid uses the Clenshaw-Curtis quadrature, hence the name. As a reduced grid it has a different number of longitude points on every latitude ring.  These grids are called octahedral because after starting with 20 points on the first ring around the north pole they increase the number of longitude points for each ring by 4, such that they can be conceptually thought of as lying on the 4 faces of an octahedron on each hemisphere. Hence, these grids have 20, 24, 28, ... longitude points for ring 1, 2, 3, ... There is a ring on the Equator with 16 + 4nlat_half longitude points before reducing the number of longitude points per ring by 4 towards the southern-most ring j = nlat. The first point on every ring is at longitude 0˚E, i.e. no offset is applied to the longitude values (in contrast to HEALPix grids).</p><p>The first dimension of data on this grid (a <code>Field</code>) represents the horizontal dimension, in ring order (0 to 360˚E, then north to south), other dimensions can be used for the vertical and/or time or other dimensions.  Note that a <code>Grid</code> does not contain any data, it only describes the discretization of the space, see <code>Field</code> for a data on a <code>Grid</code>.  But a &quot;grid&quot; only defines the two horizontal dimensions, two fields, one 2D and one 3D, possibly different ArrayTypes or element types, can share the same grid which just defines the discretization and the architecture (CPU/GPU) the grid is on.</p><p>The resolution parameter of the horizontal grid is <code>nlat_half</code> (number of latitude rings on one hemisphere, Equator included) <code>rings</code> are the precomputed ring indices, the the example above <code>rings = [1:20, 21:44, 45:72, ...]</code>.  <code>whichring</code> is a precomputed vector of ring indices for each grid point ij, i.e. <code>whichring[ij]</code> gives the ring index j of grid point ij. For efficient looping see <code>eachring</code> and <code>eachgrid</code>. Fields are</p><ul><li><p><code>nlat_half::Int64</code></p></li><li><p><code>architecture::Any</code></p></li><li><p><code>rings::Any</code></p></li><li><p><code>whichring::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/octahedral_clenshaw.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.OctahedralGaussianGrid" href="#SpeedyWeather.RingGrids.OctahedralGaussianGrid"><code>SpeedyWeather.RingGrids.OctahedralGaussianGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An <code>OctahedralGaussianGrid</code> is a discretization of the sphere that uses Gaussian latitudes for each latitude ring. As a reduced grid it has a different number of longitude points on every latitude ring.  These grids are called octahedral because after starting with 20 points on the first ring around the north pole they increase the number of longitude points for each ring by 4, such that they can be conceptually thought of as lying on the 4 faces of an octahedron on each hemisphere. Hence, these grids have 20, 24, 28, ... longitude points for ring 1, 2, 3, ... There is no ring on the Equator and the two rings around it have 16 + 4nlat_half longitude points before reducing the number of longitude points per ring by 4 towards the southern-most ring j = nlat. The first point on every ring is at longitude 0˚E, i.e. no offset is applied to the longitude values (in contrast to HEALPix grids).</p><p>The first dimension of data on this grid (a <code>Field</code>) represents the horizontal dimension, in ring order (0 to 360˚E, then north to south), other dimensions can be used for the vertical and/or time or other dimensions.  Note that a <code>Grid</code> does not contain any data, it only describes the discretization of the space, see <code>Field</code> for a data on a <code>Grid</code>.  But a &quot;grid&quot; only defines the two horizontal dimensions, two fields, one 2D and one 3D, possibly different ArrayTypes or element types, can share the same grid which just defines the discretization and the architecture (CPU/GPU) the grid is on.</p><p>The resolution parameter of the horizontal grid is <code>nlat_half</code> (number of latitude rings on one hemisphere, Equator included) <code>rings</code> are the precomputed ring indices, the the example above <code>rings = [1:20, 21:44, 45:72, ...]</code>.  <code>whichring</code> is a precomputed vector of ring indices for each grid point ij, i.e. <code>whichring[ij]</code> gives the ring index j of grid point ij. For efficient looping see <code>eachring</code> and <code>eachgrid</code>. Fields are</p><ul><li><p><code>nlat_half::Int64</code></p></li><li><p><code>architecture::Any</code></p></li><li><p><code>rings::Any</code></p></li><li><p><code>whichring::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/octahedral_gaussian.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.OctaminimalGaussianGrid" href="#SpeedyWeather.RingGrids.OctaminimalGaussianGrid"><code>SpeedyWeather.RingGrids.OctaminimalGaussianGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An <code>OctaminimalGaussianGrid</code> is a discretization of the sphere that uses Gaussian latitudes for each latitude ring. It is very similar to the <code>OctahedralGaussianGrid</code>, with a few differences:</p><ol><li>It starts with 4 longitude points around the poles, so 4, 8, 12, 16, ... on ring 1, 2, 3, 4, ... reducing the number</li></ol><p>of total number of grid points over the <code>OctahedralGaussianGrid</code>, hence the name &quot;octaminimal&quot; (octahedral minimal).</p><ol><li>The first longitude points on every ring have an offset, such that the cell face between the first and last longitude point on every ring is at 0˚E (like the HEALPix grid)</li></ol><p>Fields are</p><ul><li><p><code>nlat_half::Int64</code></p></li><li><p><code>architecture::Any</code></p></li><li><p><code>rings::Any</code></p></li><li><p><code>whichring::Any</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/octaminimal_gaussian.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids._scale_lat!-Tuple{AbstractField, AbstractVector}" href="#SpeedyWeather.RingGrids._scale_lat!-Tuple{AbstractField, AbstractVector}"><code>SpeedyWeather.RingGrids._scale_lat!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_scale_lat!(
    field::AbstractField,
    v::AbstractVector
) -&gt; AbstractField
</code></pre><p>Generic latitude scaling applied to <code>field</code> in-place with latitude-like vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/scaling.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.anvil_average-NTuple{7, Any}" href="#SpeedyWeather.RingGrids.anvil_average-NTuple{7, Any}"><code>SpeedyWeather.RingGrids.anvil_average</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">anvil_average(a, b, c, d, Δab, Δcd, Δy) -&gt; Any
</code></pre><p>The bilinear average of a, b, c, d which are values at grid points in an anvil-shaped configuration at location x, which is denoted by Δab, Δcd, Δy, the fraction of distances between a-b, c-d, and ab-cd, respectively. Note that a, c and b, d do not necessarily share the same longitude/x-coordinate. See schematic:</p><pre><code class="nohighlight hljs">            0..............1    # fraction of distance Δab between a, b
            |&lt;  Δab   &gt;|

    0^      a -------- o - b    # anvil-shaped average of a, b, c, d at location x
    .Δy                |
    .                  |
    .v                 x 
    .                  |
    1         c ------ o ---- d

              |&lt;  Δcd &gt;|
              0...............1 # fraction of distance Δcd between c, d</code></pre><p>^ fraction of distance Δy between a-b and c-d.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/interpolation.jl#L512">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.average_on_poles-Union{Tuple{NF}, Tuple{AbstractVector{NF}, AbstractVector}} where NF&lt;:AbstractFloat" href="#SpeedyWeather.RingGrids.average_on_poles-Union{Tuple{NF}, Tuple{AbstractVector{NF}, AbstractVector}} where NF&lt;:AbstractFloat"><code>SpeedyWeather.RingGrids.average_on_poles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">average_on_poles(
    A::AbstractArray{NF&lt;:AbstractFloat, 1},
    rings::AbstractVector
) -&gt; Tuple{Any, Any}
</code></pre><p>Computes the average at the North and South pole from a given grid <code>A</code> and it&#39;s precomputed ring indices <code>rings</code>. The North pole average is an equally weighted average of all grid points on the northern-most ring. Similar for the South pole.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/interpolation.jl#L491">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.average_on_poles-Union{Tuple{NF}, Tuple{AbstractVector{NF}, AbstractVector}} where NF&lt;:Integer" href="#SpeedyWeather.RingGrids.average_on_poles-Union{Tuple{NF}, Tuple{AbstractVector{NF}, AbstractVector}} where NF&lt;:Integer"><code>SpeedyWeather.RingGrids.average_on_poles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">average_on_poles(
    A::AbstractArray{NF&lt;:Integer, 1},
    rings::AbstractVector
) -&gt; Tuple{Any, Any}
</code></pre><p>Method for <code>A::Abstract{T&lt;:Integer}</code> which rounds the averaged values to return the same number format <code>NF</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/interpolation.jl#L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.clenshaw_curtis_weights-Tuple{Integer}" href="#SpeedyWeather.RingGrids.clenshaw_curtis_weights-Tuple{Integer}"><code>SpeedyWeather.RingGrids.clenshaw_curtis_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clenshaw_curtis_weights(nlat_half::Integer) -&gt; Any
</code></pre><p>The Clenshaw-Curtis weights for a Clenshaw grid (full or octahedral) of size nlat<em>half. Clenshaw-Curtis weights are of length <code>nlat</code>, i.e. a vector for every latitude ring, pole to pole. `sum(clenshaw</em>curtis<em>weights(nlat</em>half))<code>is always</code>2` as int<em>0^π sin(x) dx = 2 (colatitudes), or equivalently int</em>-pi/2^pi/2 cos(x) dx (latitudes).</p><p>Integration (and therefore the spectral transform) is <em>exact</em> (only rounding errors) when using Clenshaw grids provided that nlat &gt;= 2(T + 1), meaning that a grid resolution of at least 128x64 (nlon x nlat) is sufficient for an exact transform with a T=31 spectral truncation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/quadrature_weights.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.each_index_in_ring!-Tuple{AbstractVector, Type{&lt;:OctahedralGaussianGrid}, Integer}" href="#SpeedyWeather.RingGrids.each_index_in_ring!-Tuple{AbstractVector, Type{&lt;:OctahedralGaussianGrid}, Integer}"><code>SpeedyWeather.RingGrids.each_index_in_ring!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">each_index_in_ring!(
    rings::AbstractVector,
    Grid::Type{&lt;:OctahedralGaussianGrid},
    nlat_half::Integer
)
</code></pre><p>precompute a <code>Vector{UnitRange{Int}} to index grid points on every ring</code>j<code>(elements of the vector) of</code>Grid<code>at resolution</code>nlat_half<code>. See</code>eachring<code>and</code>eachgrid` for efficient looping over grid points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/octahedral_gaussian.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.each_index_in_ring!-Tuple{AbstractVector, Type{&lt;:OctaminimalGaussianGrid}, Integer}" href="#SpeedyWeather.RingGrids.each_index_in_ring!-Tuple{AbstractVector, Type{&lt;:OctaminimalGaussianGrid}, Integer}"><code>SpeedyWeather.RingGrids.each_index_in_ring!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">each_index_in_ring!(
    rings::AbstractVector,
    Grid::Type{&lt;:OctaminimalGaussianGrid},
    nlat_half::Integer
)
</code></pre><p>precompute a <code>Vector{UnitRange{Int}} to index grid points on every ring</code>j<code>(elements of the vector) of</code>Grid<code>at resolution</code>nlat_half<code>. See</code>eachring<code>and</code>eachgrid` for efficient looping over grid points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/octaminimal_gaussian.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.each_index_in_ring-Tuple{AbstractGrid, Integer}" href="#SpeedyWeather.RingGrids.each_index_in_ring-Tuple{AbstractGrid, Integer}"><code>SpeedyWeather.RingGrids.each_index_in_ring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">each_index_in_ring(grid::AbstractGrid, j::Integer) -&gt; Any
</code></pre><p>UnitRange to access data on grid <code>grid</code> on ring <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.each_index_in_ring-Tuple{Type{&lt;:AbstractFullGrid}, Integer, Integer}" href="#SpeedyWeather.RingGrids.each_index_in_ring-Tuple{Type{&lt;:AbstractFullGrid}, Integer, Integer}"><code>SpeedyWeather.RingGrids.each_index_in_ring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">each_index_in_ring(
    Grid::Type{&lt;:AbstractFullGrid},
    j::Integer,
    nlat_half::Integer
) -&gt; Any
</code></pre><p><code>UnitRange</code> for every grid point of full grid <code>Grid</code> of resolution <code>nlat_half</code> on ring <code>j</code> (<code>j=1</code> is closest ring around north pole, <code>j=nlat</code> around south pole).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/full_grids.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.eachgridpoint-Tuple{AbstractField, Vararg{AbstractField}}" href="#SpeedyWeather.RingGrids.eachgridpoint-Tuple{AbstractField, Vararg{AbstractField}}"><code>SpeedyWeather.RingGrids.eachgridpoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachgridpoint(
    field1::AbstractField,
    fields::AbstractField...;
    horizontal_only,
    kwargs...
) -&gt; Base.OneTo
</code></pre><p>Iterator over all 2D grid points of a field (or fields), i.e. the horizontal dimension only. Intended use is like    </p><pre><code class="nohighlight hljs">for ij in eachgridpoint(field)
    field[ij]</code></pre><p>for a 2D field. For a 3D+ field, the iterator will only index and loop over the horizontal grid points. If <code>horizontal_only</code> is set to <code>true</code> (default), the function will only check whether the horizontal dimensions match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/field.jl#L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.eachgridpoint-Tuple{AbstractGrid, Vararg{AbstractGrid}}" href="#SpeedyWeather.RingGrids.eachgridpoint-Tuple{AbstractGrid, Vararg{AbstractGrid}}"><code>SpeedyWeather.RingGrids.eachgridpoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachgridpoint(
    grid1::AbstractGrid,
    grids::AbstractGrid...
) -&gt; Base.OneTo
</code></pre><p>Like <code>eachgridpoint(::AbstractGrid)</code> but checks <code>grids</code> match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.eachgridpoint-Tuple{AbstractGrid}" href="#SpeedyWeather.RingGrids.eachgridpoint-Tuple{AbstractGrid}"><code>SpeedyWeather.RingGrids.eachgridpoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachgridpoint(grid::AbstractGrid) -&gt; Base.OneTo
</code></pre><p>UnitRange to access each horizontal grid point on grid <code>grid</code>. For a <code>NxM</code> (<code>N</code> horizontal grid points, <code>M</code> vertical layers) <code>OneTo(N)</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L231-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.eachlayer-Tuple{AbstractField, Vararg{AbstractField}}" href="#SpeedyWeather.RingGrids.eachlayer-Tuple{AbstractField, Vararg{AbstractField}}"><code>SpeedyWeather.RingGrids.eachlayer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachlayer(
    field1::AbstractField,
    fields::AbstractField...;
    vertical_only,
    kwargs...
) -&gt; Any
</code></pre><p>CartesianIndices for the 2nd to last dimension of a field (or fields), e.g. the vertical layer (and possibly a time dimension, etc). E.g. for a Nx2x3 field, with <code>N</code> horizontal grid points k iterates over (1, 1) to (2, 3), meaning both the 2nd  and 3rd dimension. To be used like</p><pre><code class="nohighlight hljs">for k in eachlayer(field)
    for (j, ring) in enumerate(eachring(field))
        for ij in ring
            field[ij, k]</code></pre><p>With <code>vertical_only=true</code> (default) only checks whether the non-horizontal dimensions of the fields match. E.g. one can loop over two fields of each n layers on different grids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/field.jl#L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.eachring-Tuple{AbstractField, Vararg{AbstractField}}" href="#SpeedyWeather.RingGrids.eachring-Tuple{AbstractField, Vararg{AbstractField}}"><code>SpeedyWeather.RingGrids.eachring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachring(
    field1::AbstractField,
    fields::AbstractField...;
    horizontal_only,
    kwargs...
) -&gt; Any
</code></pre><p>Return an iterator over the rings of a field. These are precomputed ranges like [1:20, 21:44, ...] stored in <code>field.grid.rings</code>. Every element are the unravellend indices <code>ij</code> of all 2D grid points that lie on that ring. Intended use is like</p><pre><code class="nohighlight hljs">for (j, ring) in enumerate(eachring(field))
    for ij in ring
        field[ij, k]</code></pre><p>with <code>j</code> being the ring index. j=1 around the north pole, j=nlat<em>half around the Equator or just north of it (for even nlat</em>half). Several fields can be passed on to check for matching grids, e.g. for a 2D and a 3D field. If <code>horizontal_only</code> is set to <code>true</code>, the function will only check the horizontal dimension. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/field.jl#L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.eachring-Tuple{AbstractGrid, Vararg{AbstractGrid}}" href="#SpeedyWeather.RingGrids.eachring-Tuple{AbstractGrid, Vararg{AbstractGrid}}"><code>SpeedyWeather.RingGrids.eachring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachring(grid1::AbstractGrid, grids::AbstractGrid...) -&gt; Any
</code></pre><p>Same as <code>eachring(grid)</code> but performs a bounds check to assess that all <code>grids</code> according to <code>grids_match</code> (non-parametric grid type, nlat_half and length).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.eachring-Tuple{AbstractGrid}" href="#SpeedyWeather.RingGrids.eachring-Tuple{AbstractGrid}"><code>SpeedyWeather.RingGrids.eachring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachring(grid::AbstractGrid) -&gt; Any
</code></pre><p>Vector{UnitRange} <code>rings</code> to loop over every ring of <code>grid</code> and then each grid point per ring. To be used like</p><pre><code class="nohighlight hljs">rings = eachring(grid)
for ring in rings
    for ij in ring
        field[ij]</code></pre><p>Accesses precomputed <code>grid.rings</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.eachring-Tuple{Type{&lt;:AbstractGrid}, Integer}" href="#SpeedyWeather.RingGrids.eachring-Tuple{Type{&lt;:AbstractGrid}, Integer}"><code>SpeedyWeather.RingGrids.eachring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachring(
    Grid::Type{&lt;:AbstractGrid},
    nlat_half::Integer
) -&gt; Any
</code></pre><p>Computes the ring indices <code>i0:i1</code> for start and end of every longitudinal point on a given ring <code>j</code> of <code>Grid</code> at resolution <code>nlat_half</code>. Used to loop over rings of a grid. These indices are also precomputed in every <code>grid.rings</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.equal_area_weights-Tuple{Type{&lt;:AbstractGrid}, Integer}" href="#SpeedyWeather.RingGrids.equal_area_weights-Tuple{Type{&lt;:AbstractGrid}, Integer}"><code>SpeedyWeather.RingGrids.equal_area_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">equal_area_weights(
    Grid::Type{&lt;:AbstractGrid},
    nlat_half::Integer
) -&gt; Any
</code></pre><p>The equal-area weights used for the HEALPix grids (original or OctaHEALPix) of size nlat<em>half. The weights are of length <code>nlat</code>, i.e. a vector for every latitude ring, pole to pole. `sum(equal</em>area<em>weights(nlat</em>half))<code>is always</code>2` as int<em>0^π sin(x) dx = 2 (colatitudes), or equivalently int</em>-pi/2^pi/2 cos(x) dx (latitudes). Integration (and therefore the spectral transform) is not exact with these grids but errors reduce for higher resolution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/quadrature_weights.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.extrema_in-Tuple{AbstractVector, Real, Real}" href="#SpeedyWeather.RingGrids.extrema_in-Tuple{AbstractVector, Real, Real}"><code>SpeedyWeather.RingGrids.extrema_in</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extrema_in(v::AbstractVector, a::Real, b::Real) -&gt; Any
</code></pre><p>For every element vᵢ in v does a&lt;=vi&lt;=b hold?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/utility_functions.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.fields_match-Tuple{AbstractField, AbstractField}" href="#SpeedyWeather.RingGrids.fields_match-Tuple{AbstractField, AbstractField}"><code>SpeedyWeather.RingGrids.fields_match</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fields_match(
    A::AbstractField,
    B::AbstractField;
    horizontal_only,
    vertical_only
) -&gt; Any
</code></pre><p>True if both <code>A</code> and <code>B</code> are of the same nonparametric grid type (e.g. OctahedralGaussianArray, regardless type parameter <code>T</code> or underyling array type <code>ArrayType</code>) and of same resolution (<code>nlat_half</code>) and total grid points (<code>length</code>). Sizes of <code>(4,)</code> and <code>(4,1)</code> would match for example, but <code>(8,1)</code> and <code>(4,2)</code> would not (<code>nlat_half</code> not identical).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/field.jl#L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.gaussian_weights-Tuple{Integer}" href="#SpeedyWeather.RingGrids.gaussian_weights-Tuple{Integer}"><code>SpeedyWeather.RingGrids.gaussian_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussian_weights(nlat_half::Integer) -&gt; Any
</code></pre><p>The Gaussian weights for a Gaussian grid (full or octahedral) of size nlat<em>half. Gaussian weights are of length <code>nlat</code>, i.e. a vector for every latitude ring, pole to pole. `sum(gaussian</em>weights(nlat<em>half))<code>is always</code>2` as int</em>0^π sin(x) dx = 2 (colatitudes), or equivalently int_-pi/2^pi/2 cos(x) dx (latitudes).</p><p>Integration (and therefore the spectral transform) is <em>exact</em> (only rounding errors) when using Gaussian grids provided that nlat &gt;= 3(T + 1)/2, meaning that a grid resolution of at least 96x48 (nlon x nlat) is sufficient for an exact transform with a T=31 spectral truncation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/quadrature_weights.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_colat-Tuple{Grid} where Grid&lt;:AbstractGrid" href="#SpeedyWeather.RingGrids.get_colat-Tuple{Grid} where Grid&lt;:AbstractGrid"><code>SpeedyWeather.RingGrids.get_colat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_colat(grid::AbstractGrid) -&gt; Any
</code></pre><p>Colatitudes (radians) for each ring in <code>grid</code>, north to south.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_gridcell_polygons-Tuple{Type{&lt;:AbstractGrid}, Integer}" href="#SpeedyWeather.RingGrids.get_gridcell_polygons-Tuple{Type{&lt;:AbstractGrid}, Integer}"><code>SpeedyWeather.RingGrids.get_gridcell_polygons</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_gridcell_polygons(
    Grid::Type{&lt;:AbstractGrid},
    nlat_half::Integer;
    add_nan
) -&gt; Matrix{Tuple{Float64, Float64}}
</code></pre><p>Return a 5xN matrix <code>polygons</code> (or grid cells) of <code>NTuple{2, Float64}</code> where the first 4 rows are the vertices (E, S, W, N) of every grid points ij in 1:N, row 5 is duplicated north vertex to close the grid cell. Use keyword arguemnt <code>add_nan=true</code> (default <code>false</code>) to add a 6th row with (NaN, NaN) to separate grid cells when drawing them as a continuous line with <code>vec(polygons)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/vertices.jl#L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_lat-Tuple{Grid} where Grid&lt;:AbstractGrid" href="#SpeedyWeather.RingGrids.get_lat-Tuple{Grid} where Grid&lt;:AbstractGrid"><code>SpeedyWeather.RingGrids.get_lat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lat(grid::AbstractGrid) -&gt; Any
</code></pre><p>Latitude (radians) for each ring in <code>grid</code>, north to south.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_latd-Tuple{Grid} where Grid&lt;:AbstractGrid" href="#SpeedyWeather.RingGrids.get_latd-Tuple{Grid} where Grid&lt;:AbstractGrid"><code>SpeedyWeather.RingGrids.get_latd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_latd(grid::AbstractGrid) -&gt; Any
</code></pre><p>Latitude (degrees) for each ring in <code>grid</code>, north to south.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_latd-Tuple{Type{&lt;:HEALPixGrid}, Integer}" href="#SpeedyWeather.RingGrids.get_latd-Tuple{Type{&lt;:HEALPixGrid}, Integer}"><code>SpeedyWeather.RingGrids.get_latd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_latd(_::Type{&lt;:HEALPixGrid}, nlat_half::Integer) -&gt; Any
</code></pre><p>Latitudes [90˚N to -90˚N] for the <code>HEALPixGrid</code> with resolution parameter <code>nlat_half</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/healpix.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_lon-Tuple{Grid} where Grid&lt;:AbstractGrid" href="#SpeedyWeather.RingGrids.get_lon-Tuple{Grid} where Grid&lt;:AbstractGrid"><code>SpeedyWeather.RingGrids.get_lon</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lon(grid::AbstractGrid) -&gt; Any
</code></pre><p>Longitude (radians). Full grids only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_loncolats-Tuple{Grid} where Grid&lt;:AbstractGrid" href="#SpeedyWeather.RingGrids.get_loncolats-Tuple{Grid} where Grid&lt;:AbstractGrid"><code>SpeedyWeather.RingGrids.get_loncolats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_loncolats(grid::AbstractGrid) -&gt; Tuple{Any, Any}
</code></pre><p>Longitudes (radians, 0-2π), colatitudes (degrees, 0 to π) for every (horizontal) grid point in <code>grid</code> in ring order (0-360˚E then north to south).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_lond-Tuple{Grid} where Grid&lt;:AbstractGrid" href="#SpeedyWeather.RingGrids.get_lond-Tuple{Grid} where Grid&lt;:AbstractGrid"><code>SpeedyWeather.RingGrids.get_lond</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lond(grid::AbstractGrid) -&gt; Any
</code></pre><p>Longitude (degrees). Full grids only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_lond_per_ring-Tuple{Type{&lt;:HEALPixGrid}, Integer, Integer}" href="#SpeedyWeather.RingGrids.get_lond_per_ring-Tuple{Type{&lt;:HEALPixGrid}, Integer, Integer}"><code>SpeedyWeather.RingGrids.get_lond_per_ring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lond_per_ring(
    Grid::Type{&lt;:HEALPixGrid},
    nlat_half::Integer,
    j::Integer
) -&gt; Any
</code></pre><p>Longitudes [0˚E to 360˚E] for the <code>HEALPixGrid</code> with resolution parameter <code>nlat_half</code> on ring <code>j</code> (north to south).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/healpix.jl#L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_londlatds-Tuple{Grid} where Grid&lt;:AbstractGrid" href="#SpeedyWeather.RingGrids.get_londlatds-Tuple{Grid} where Grid&lt;:AbstractGrid"><code>SpeedyWeather.RingGrids.get_londlatds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_londlatds(grid::AbstractGrid) -&gt; Tuple{Any, Any}
</code></pre><p>Longitudes (degrees, 0-360˚E), latitudes (degrees, 90˚N to -90˚N) for every (horizontal) grid point in <code>grid</code> in ring order (0-360˚E then north to south).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_londlatds-Tuple{Type{&lt;:AbstractReducedGrid}, Integer}" href="#SpeedyWeather.RingGrids.get_londlatds-Tuple{Type{&lt;:AbstractReducedGrid}, Integer}"><code>SpeedyWeather.RingGrids.get_londlatds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_londlatds(
    Grid::Type{&lt;:AbstractReducedGrid},
    nlat_half::Integer
) -&gt; Tuple{Any, Any}
</code></pre><p>Return vectors of <code>londs</code>, <code>latds</code>, of longitudes (degrees, 0-360˚E) and latitudes (degrees, -90˚ to 90˚N) for reduced grids for all grid points in order of the running index <code>ij</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/reduced_grids.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_lonlats-Tuple{Grid} where Grid&lt;:AbstractGrid" href="#SpeedyWeather.RingGrids.get_lonlats-Tuple{Grid} where Grid&lt;:AbstractGrid"><code>SpeedyWeather.RingGrids.get_lonlats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lonlats(grid::AbstractGrid) -&gt; Tuple{Any, Any}
</code></pre><p>Longitudes (radians, 0-2π), latitudes (degrees, π/2 to -π/2) for every (horizontal) grid point in <code>grid</code> in ring order (0-360˚E then north to south).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_nlat-Tuple{AbstractGrid}" href="#SpeedyWeather.RingGrids.get_nlat-Tuple{AbstractGrid}"><code>SpeedyWeather.RingGrids.get_nlat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nlat(grid::AbstractGrid) -&gt; Any
</code></pre><p>Get number of latitude rings, pole to pole.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_nlat_half-Tuple{AbstractGrid}" href="#SpeedyWeather.RingGrids.get_nlat_half-Tuple{AbstractGrid}"><code>SpeedyWeather.RingGrids.get_nlat_half</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nlat_half(grid::AbstractGrid) -&gt; Any
</code></pre><p>Resolution paraemeters <code>nlat_half</code> of a <code>grid</code>. Number of latitude rings on one hemisphere, Equator included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_nlon_per_ring-Tuple{AbstractGrid, Integer}" href="#SpeedyWeather.RingGrids.get_nlon_per_ring-Tuple{AbstractGrid, Integer}"><code>SpeedyWeather.RingGrids.get_nlon_per_ring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nlon_per_ring(grid::AbstractGrid, j::Integer) -&gt; Any
</code></pre><p>Number of longitude points per latitude ring <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_nlon_per_ring-Tuple{Type{&lt;:HEALPixGrid}, Integer, Integer}" href="#SpeedyWeather.RingGrids.get_nlon_per_ring-Tuple{Type{&lt;:HEALPixGrid}, Integer, Integer}"><code>SpeedyWeather.RingGrids.get_nlon_per_ring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nlon_per_ring(
    Grid::Type{&lt;:HEALPixGrid},
    nlat_half::Integer,
    j::Integer
) -&gt; Any
</code></pre><p>Number of longitude points for ring <code>j</code> on <code>Grid</code> of resolution <code>nlat_half</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/healpix.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_nlons-Tuple{Type{&lt;:AbstractGrid}, Integer}" href="#SpeedyWeather.RingGrids.get_nlons-Tuple{Type{&lt;:AbstractGrid}, Integer}"><code>SpeedyWeather.RingGrids.get_nlons</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nlons(
    Grid::Type{&lt;:AbstractGrid},
    nlat_half::Integer;
    both_hemispheres
) -&gt; Any
</code></pre><p>Returns a vector <code>nlons</code> for the number of longitude points per latitude ring, north to south. Provide grid <code>Grid</code> and its resolution parameter <code>nlat_half</code>. For keyword argument <code>both_hemispheres=false</code> only the northern hemisphere (incl Equator) is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_npoints-Union{Tuple{Grid}, Tuple{Grid, Vararg{Any}}} where Grid&lt;:AbstractGrid" href="#SpeedyWeather.RingGrids.get_npoints-Union{Tuple{Grid}, Tuple{Grid, Vararg{Any}}} where Grid&lt;:AbstractGrid"><code>SpeedyWeather.RingGrids.get_npoints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_npoints(grid::AbstractGrid, args...) -&gt; Any
</code></pre><p>Total number of grid points in all dimensions of <code>grid</code>. Equivalent to length of the underlying data array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_vertices-Tuple{Type{&lt;:AbstractFullGrid}, Integer}" href="#SpeedyWeather.RingGrids.get_vertices-Tuple{Type{&lt;:AbstractFullGrid}, Integer}"><code>SpeedyWeather.RingGrids.get_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_vertices(
    Grid::Type{&lt;:AbstractFullGrid},
    nlat_half::Integer
) -&gt; NTuple{4, Any}
</code></pre><p>Vertices for full grids, other definition than for reduced grids to prevent a diamond shape of the cells. Use default rectangular instead. Effectively rotating the vertices clockwise by 45˚, making east south-east etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/vertices.jl#L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.get_vertices-Tuple{Type{&lt;:AbstractGrid}, Integer}" href="#SpeedyWeather.RingGrids.get_vertices-Tuple{Type{&lt;:AbstractGrid}, Integer}"><code>SpeedyWeather.RingGrids.get_vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_vertices(
    Grid::Type{&lt;:AbstractGrid},
    nlat_half::Integer
) -&gt; NTuple{4, Any}
</code></pre><p>Vertices are defined for every grid point on a ring grid through 4 points: east, south, west, north.</p><pre><code class="nohighlight hljs">- east: longitude mid-point with the next grid point east
- south: longitude mid-point between the two closest grid points on one ring to the south
- west: longitude mid-point with the next grid point west
- north: longitude mid-point between the two closest grid points on one ring to the north</code></pre><p>Example</p><pre><code class="nohighlight hljs">   o ----- n ------ o

o --- w --- c --- e --- o

     o ----- s ------ o</code></pre><p>with cell center c (the grid point), e, s, w, n the vertices and o the surrounding grid points. Returns 2xnpoints arrays for east, south, west, north each containing the longitude and latitude of the vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/vertices.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.grid_cell_average!-Tuple{AbstractField, AbstractField{T, N, ArrayType, Grid} where {T, N, ArrayType, Grid&lt;:AbstractFullGrid}}" href="#SpeedyWeather.RingGrids.grid_cell_average!-Tuple{AbstractField, AbstractField{T, N, ArrayType, Grid} where {T, N, ArrayType, Grid&lt;:AbstractFullGrid}}"><code>SpeedyWeather.RingGrids.grid_cell_average!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_cell_average!(
    output::AbstractField,
    input::AbstractField{T, N, ArrayType, Grid} where {T, N, ArrayType, Grid&lt;:AbstractFullGrid}
) -&gt; AbstractField
</code></pre><p>Averages all grid points in <code>input</code> that are within one grid cell of <code>output</code> with coslat-weighting. The output grid cell boundaries  are assumed to be rectangles spanning half way to adjacent longitude and latitude points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/interpolation.jl#L552">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.grid_cell_average-Tuple{Type{&lt;:AbstractGrid}, Integer, AbstractFullGrid}" href="#SpeedyWeather.RingGrids.grid_cell_average-Tuple{Type{&lt;:AbstractGrid}, Integer, AbstractFullGrid}"><code>SpeedyWeather.RingGrids.grid_cell_average</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_cell_average(
    Grid::Type{&lt;:AbstractGrid},
    nlat_half::Integer,
    input::AbstractFullGrid
)
</code></pre><p>Averages all grid points in <code>input</code> that are within one grid cell of <code>output</code> with coslat-weighting. The output grid cell boundaries  are assumed to be rectangles spanning half way to adjacent longitude and latitude points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/interpolation.jl#L632">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.grids_match-Tuple{AbstractGrid, AbstractGrid}" href="#SpeedyWeather.RingGrids.grids_match-Tuple{AbstractGrid, AbstractGrid}"><code>SpeedyWeather.RingGrids.grids_match</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grids_match(A::AbstractGrid, B::AbstractGrid) -&gt; Any
</code></pre><p>True if both <code>A</code> and <code>B</code> are of the same nonparametric grid type (e.g. OctahedralGaussianArray, regardless type parameter <code>T</code> or underyling array type <code>ArrayType</code>) and of same resolution (<code>nlat_half</code>) and total grid points (<code>length</code>). Sizes of <code>(4,)</code> and <code>(4,1)</code> would match for example, but <code>(8,1)</code> and <code>(4,2)</code> would not (<code>nlat_half</code> not identical).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.grids_match-Tuple{AbstractGrid, Vararg{AbstractGrid}}" href="#SpeedyWeather.RingGrids.grids_match-Tuple{AbstractGrid, Vararg{AbstractGrid}}"><code>SpeedyWeather.RingGrids.grids_match</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grids_match(A::AbstractGrid, Bs::AbstractGrid...) -&gt; Any
</code></pre><p>True if all grids <code>A, B, C, ...</code> provided as arguments match according to <code>grids_match</code> wrt to <code>A</code> (and therefore all).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.grids_match-Tuple{Type{&lt;:AbstractGrid}, Type{&lt;:AbstractGrid}}" href="#SpeedyWeather.RingGrids.grids_match-Tuple{Type{&lt;:AbstractGrid}, Type{&lt;:AbstractGrid}}"><code>SpeedyWeather.RingGrids.grids_match</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grids_match(
    A::Type{&lt;:AbstractGrid},
    B::Type{&lt;:AbstractGrid}
) -&gt; Any
</code></pre><p>True if both <code>A</code> and <code>B</code> are of the same nonparametric grid type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.isdecreasing-Tuple{AbstractVector}" href="#SpeedyWeather.RingGrids.isdecreasing-Tuple{AbstractVector}"><code>SpeedyWeather.RingGrids.isdecreasing</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdecreasing(x::AbstractVector) -&gt; Bool
</code></pre><p>Check whether elements of a vector <code>v</code> are strictly decreasing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/utility_functions.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.isincreasing-Tuple{AbstractVector}" href="#SpeedyWeather.RingGrids.isincreasing-Tuple{AbstractVector}"><code>SpeedyWeather.RingGrids.isincreasing</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isincreasing(x::AbstractVector) -&gt; Bool
</code></pre><p>Check whether elements of a vector <code>v</code> are strictly increasing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/utility_functions.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.matrix_size-Tuple{Grid} where Grid&lt;:AbstractGrid" href="#SpeedyWeather.RingGrids.matrix_size-Tuple{Grid} where Grid&lt;:AbstractGrid"><code>SpeedyWeather.RingGrids.matrix_size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix_size(grid::AbstractGrid) -&gt; Tuple{Int64, Int64}
</code></pre><p>Size of the matrix of the horizontal grid if representable as such (not all grids).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.nlat_odd-Tuple{AbstractGrid}" href="#SpeedyWeather.RingGrids.nlat_odd-Tuple{AbstractGrid}"><code>SpeedyWeather.RingGrids.nlat_odd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nlat_odd(grid::AbstractGrid) -&gt; Any
</code></pre><p>True for a <code>grid</code> that has an odd number of latitude rings <code>nlat</code> (both hemispheres).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.nonparametric_type-Tuple{AbstractGrid}" href="#SpeedyWeather.RingGrids.nonparametric_type-Tuple{AbstractGrid}"><code>SpeedyWeather.RingGrids.nonparametric_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nonparametric_type(grid::AbstractGrid) -&gt; Any
</code></pre><p>For any instance of <code>AbstractGrid</code> type its n-dimensional type (*Grid{T, N, ...} returns *Array) but without any parameters <code>{T, N, ArrayType}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.nside_healpix-Tuple{Integer}" href="#SpeedyWeather.RingGrids.nside_healpix-Tuple{Integer}"><code>SpeedyWeather.RingGrids.nside_healpix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nside_healpix(nlat_half::Integer) -&gt; Any
</code></pre><p>The original <code>Nside</code> resolution parameter of the HEALPix grids. The number of grid points on one side of each (square) face. While we use <code>nlat_half</code> across all ring grids, this function translates this to Nside. Even <code>nlat_half</code> only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grids/healpix.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.rotate_matrix_indices_180-Tuple{Integer, Integer, Integer}" href="#SpeedyWeather.RingGrids.rotate_matrix_indices_180-Tuple{Integer, Integer, Integer}"><code>SpeedyWeather.RingGrids.rotate_matrix_indices_180</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_matrix_indices_180(
    i::Integer,
    j::Integer,
    s::Integer
) -&gt; Tuple{Any, Any}
</code></pre><p>Rotate indices <code>i, j</code> of a square matrix of size s x s by 180˚.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/utility_functions.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.rotate_matrix_indices_270-Tuple{Integer, Integer, Integer}" href="#SpeedyWeather.RingGrids.rotate_matrix_indices_270-Tuple{Integer, Integer, Integer}"><code>SpeedyWeather.RingGrids.rotate_matrix_indices_270</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_matrix_indices_270(
    i::Integer,
    j::Integer,
    s::Integer
) -&gt; Tuple{Integer, Any}
</code></pre><p>Rotate indices <code>i, j</code> of a square matrix of size s x s anti-clockwise by 270˚.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/utility_functions.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.rotate_matrix_indices_90-Tuple{Integer, Integer, Integer}" href="#SpeedyWeather.RingGrids.rotate_matrix_indices_90-Tuple{Integer, Integer, Integer}"><code>SpeedyWeather.RingGrids.rotate_matrix_indices_90</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate_matrix_indices_90(
    i::Integer,
    j::Integer,
    s::Integer
) -&gt; Tuple{Any, Integer}
</code></pre><p>Rotate indices <code>i, j</code> of a square matrix of size s x s anti-clockwise by 90˚.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/utility_functions.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.spherical_distance-Tuple{Type{&lt;:SpeedyWeather.RingGrids.AbstractSphericalDistance}, Vararg{Any}}" href="#SpeedyWeather.RingGrids.spherical_distance-Tuple{Type{&lt;:SpeedyWeather.RingGrids.AbstractSphericalDistance}, Vararg{Any}}"><code>SpeedyWeather.RingGrids.spherical_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spherical_distance(
    Formula::Type{&lt;:SpeedyWeather.RingGrids.AbstractSphericalDistance},
    args...;
    kwargs...
) -&gt; Any
</code></pre><p>Spherical distance, or great-circle distance, between two points <code>lonlat1</code> and <code>lonlat2</code> using the <code>Formula</code> (default <code>Haversine</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/geodesics.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.whichring-Tuple{Integer, AbstractVector}" href="#SpeedyWeather.RingGrids.whichring-Tuple{Integer, AbstractVector}"><code>SpeedyWeather.RingGrids.whichring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">whichring(ij::Integer, rings::AbstractVector) -&gt; Int64
</code></pre><p>Obtain ring index <code>j</code> from gridpoint <code>ij</code> and <code>rings</code> describing rind indices as obtained from <code>eachring(::Grid)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.whichring-Tuple{Type{&lt;:AbstractGrid}, Any, AbstractVector}" href="#SpeedyWeather.RingGrids.whichring-Tuple{Type{&lt;:AbstractGrid}, Any, AbstractVector}"><code>SpeedyWeather.RingGrids.whichring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">whichring(
    Grid::Type{&lt;:AbstractGrid},
    nlat_half,
    rings::AbstractVector
) -&gt; Any
</code></pre><p>Vector of ring indices for every grid point in <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/grid.jl#L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpeedyWeather.RingGrids.zonal_mean-Tuple{AbstractField}" href="#SpeedyWeather.RingGrids.zonal_mean-Tuple{AbstractField}"><code>SpeedyWeather.RingGrids.zonal_mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zonal_mean(field::AbstractField) -&gt; Any
</code></pre><p>Zonal mean of <code>grid</code>, i.e. along its latitude rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/c717396ea9bd0d99c243a45079f1c859d4303c2f/src/RingGrids/statistics.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../grids/">« Grids</a><a class="docs-footer-nextpage" href="../lowertriangularmatrices/">LowerTriangularArrays »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Wednesday 18 June 2025 11:35">Wednesday 18 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
